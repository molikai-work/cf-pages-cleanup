name: Cleanup Cloudflare Pages Deployments

on:
  workflow_dispatch:
    inputs:
      parameters:
        description: "JSON string of environment variables"
        required: true
        type: string

jobs:
  cleanup:
    name: Delete old Cloudflare Pages deployments
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repo
        uses: actions/checkout@v3

      - name: Install jq
        run: sudo apt-get install jq -y

      - name: Parse input JSON and set env vars
        run: |
          PARAMS='${{ github.event.inputs.parameters }}'
          echo "$PARAMS" > params.json

          echo "CF_API_TOKEN=$(jq -r '.CF_API_TOKEN' params.json)" >> $GITHUB_ENV
          echo "CF_ACCOUNT_ID=$(jq -r '.CF_ACCOUNT_ID' params.json)" >> $GITHUB_ENV
          echo "CF_PAGES_PROJECT_NAME=$(jq -r '.CF_PAGES_PROJECT_NAME' params.json)" >> $GITHUB_ENV
          echo "CF_DELETE_ALIASED_DEPLOYMENTS=$(jq -r '.CF_DELETE_ALIASED_DEPLOYMENTS' params.json)" >> $GITHUB_ENV

      - name: Run cleanup script
        run: |
          npm install node-fetch@2 exponential-backoff

          node <<'EOF'
          const fetch = require('node-fetch');
          const { backOff } = require('exponential-backoff');

          const CF_API_TOKEN = process.env.CF_API_TOKEN;
          const CF_ACCOUNT_ID = process.env.CF_ACCOUNT_ID;
          const CF_PAGES_PROJECT_NAME = process.env.CF_PAGES_PROJECT_NAME;
          const CF_DELETE_ALIASED_DEPLOYMENTS = process.env.CF_DELETE_ALIASED_DEPLOYMENTS;

          const MAX_ATTEMPTS = 5;

          const sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

          const headers = {
            Authorization: \`Bearer \${CF_API_TOKEN}\`,
          };

          async function getProductionDeploymentId() {
            const response = await fetch(
              \`https://api.cloudflare.com/client/v4/accounts/\${CF_ACCOUNT_ID}/pages/projects/\${CF_PAGES_PROJECT_NAME}\`,
              { method: 'GET', headers }
            );
            const body = await response.json();
            if (!body.success) throw new Error(body.errors[0].message);

            const prodDeploymentId = body.result.canonical_deployment.id;
            if (!prodDeploymentId) throw new Error('Unable to fetch production deployment ID');
            return prodDeploymentId;
          }

          async function deleteDeployment(id) {
            let params = '';
            if (CF_DELETE_ALIASED_DEPLOYMENTS === 'true') {
              params = '?force=true';
              console.warn(\`âš ï¸ Forcing deletion of aliased deployment \${id}\`);
            }
            const response = await fetch(
              \`https://api.cloudflare.com/client/v4/accounts/\${CF_ACCOUNT_ID}/pages/projects/\${CF_PAGES_PROJECT_NAME}/deployments/\${id}\${params}\`,
              { method: 'DELETE', headers }
            );
            const body = await response.json();
            if (!body.success) throw new Error(body.errors[0].message);
            console.log(\`âœ… Deleted deployment \${id}\`);
          }

          async function listDeploymentsPerPage(page) {
            const response = await fetch(
              \`https://api.cloudflare.com/client/v4/accounts/\${CF_ACCOUNT_ID}/pages/projects/\${CF_PAGES_PROJECT_NAME}/deployments?per_page=10&page=\${page}\`,
              { method: 'GET', headers }
            );
            const body = await response.json();
            if (!body.success) throw new Error(\`Could not fetch deployments: \${body.errors[0].message}\`);
            return body.result;
          }

          async function listAllDeployments() {
            let page = 1;
            const deploymentIds = [];

            while (true) {
              let result;
              try {
                result = await backOff(() => listDeploymentsPerPage(page), {
                  numOfAttempts: MAX_ATTEMPTS,
                  startingDelay: 1000,
                  retry: (_, attempt) => {
                    console.warn(\`Retrying page \${page} (\${attempt}/\${MAX_ATTEMPTS})\`);
                    return true;
                  },
                });
              } catch (err) {
                console.error(\`âŒ Failed to list deployments on page \${page}\`);
                console.error(err);
                process.exit(1);
              }

              if (result.length === 0) break;

              deploymentIds.push(...result.map((d) => d.id));
              page++;
              await sleep(500);
            }

            return deploymentIds;
          }

          async function main() {
            if (!CF_API_TOKEN || !CF_ACCOUNT_ID || !CF_PAGES_PROJECT_NAME) {
              throw new Error('Missing required environment variables');
            }

            const productionDeploymentId = await getProductionDeploymentId();
            console.log(\`ðŸš€ Production deployment ID: \${productionDeploymentId}\`);

            const allDeployments = await listAllDeployments();
            console.log(\`ðŸ” Total deployments found: \${allDeployments.length}\`);

            for (const id of allDeployments) {
              if (id === productionDeploymentId) {
                console.log(\`â­ Skipping production deployment: \${id}\`);
              } else {
                try {
                  await deleteDeployment(id);
                  await sleep(500);
                } catch (err) {
                  console.error(\`âš ï¸ Failed to delete \${id}\`);
                  console.error(err.message);
                }
              }
            }

            console.log('ðŸŽ‰ Cleanup complete');
          }

          main().catch((err) => {
            console.error('ðŸ’¥ Fatal error: ', err.message);
            process.exit(1);
          });
          EOF
